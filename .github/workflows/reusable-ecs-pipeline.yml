name: Reusable ECS Pipeline

on:
  workflow_call:
    inputs:
      deployment_name:
        description: 'Nome do deployment (ECS service)'
        required: true
        type: string
      service_type:
        description: 'Tipo de servi√ßo: api ou worker'
        required: true
        type: string
      context:
        description: 'Contexto: inbound, outbound ou platform (define qual ECR usar)'
        required: true
        type: string
      ecr_registry:
        description: 'URL do registry ECR para este contexto (ex.: vars.ECR_REGISTRY_INBOUND)'
        required: true
        type: string
      environment:
        description: 'Ambiente (dev|qa|sbx|prd); caller passa github.ref_name'
        required: true
        type: string
      use_default_dockerfile:
        description: 'true = Dockerfile do repo de templates (build/); false = do repo da aplica√ß√£o'
        required: false
        type: boolean
        default: true
      templates_repo:
        description: 'Repo dos templates (ex.: org/github-ecs); usado quando use_default_dockerfile=true'
        required: false
        type: string
        default: ''
      templates_ref:
        description: 'Branch/tag do repo de templates (ex.: main)'
        required: false
        type: string
        default: 'main'
      project_name:
        description: 'Nome do projeto .csproj (para Dockerfile padr√£o; ex.: Inbound.Nfe.Api.EnvioXml)'
        required: false
        type: string
        default: ''
      dotnet_version:
        description: 'Vers√£o do .NET SDK'
        required: false
        type: string
        default: '8.0'
      working_directory:
        description: 'Diret√≥rio do c√≥digo fonte'
        required: false
        type: string
        default: 'src'
      dockerfile_path:
        description: 'Caminho do Dockerfile (vazio = ./Dockerfile.<service_type> ou ./Dockerfile)'
        required: false
        type: string
        default: ''
      aws_region:
        description: 'Regi√£o AWS'
        required: false
        type: string
        default: 'us-east-1'
      ecs_cluster:
        description: 'Nome do cluster ECS (vazio = usa secret ECS_CLUSTER)'
        required: false
        type: string
        default: ''
      ecs_service:
        description: 'Nome do service ECS (vazio = deployment_name)'
        required: false
        type: string
        default: ''
      # --- ECS / Fargate: task definition e rede ---
      ecs_task_execution_role_arn:
        description: 'ARN da role de execu√ß√£o da task (obrigat√≥rio para criar/registrar task definition)'
        required: false
        type: string
        default: ''
      ecs_task_role_arn:
        description: 'ARN da role da task (opcional)'
        required: false
        type: string
        default: ''
      task_cpu:
        description: 'CPU para Fargate (256, 512, 1024, 2048, 4096)'
        required: false
        type: string
        default: '256'
      task_memory:
        description: 'Mem√≥ria em MB para Fargate (512, 1024, 2048, 4096, 8192)'
        required: false
        type: string
        default: '512'
      subnet_ids:
        description: 'IDs das subnets separados por v√≠rgula (ex.: subnet-1,subnet-2)'
        required: false
        type: string
        default: ''
      security_group_ids:
        description: 'IDs dos security groups separados por v√≠rgula'
        required: false
        type: string
        default: ''
      assign_public_ip:
        description: 'Atribuir IP p√∫blico (ENABLED/DISABLED) para Fargate'
        required: false
        type: string
        default: 'DISABLED'
      desired_count:
        description: 'N√∫mero desejado de tasks (para create-service)'
        required: false
        type: string
        default: '1'
      # --- API: Load Balancer (ignorado para worker) ---
      load_balancer_target_group_arn:
        description: 'ARN do target group do ALB (apenas service_type=api; worker n√£o usa LB)'
        required: false
        type: string
        default: ''
      container_name:
        description: 'Nome do container na task definition (para mapear ao LB; default: app)'
        required: false
        type: string
        default: 'app'
      container_port:
        description: 'Porta do container exposta ao ALB'
        required: false
        type: string
        default: '80'
      # --- Task definition: environment, secrets, runtime, log ---
      container_environment:
        description: 'JSON array de vari√°veis de ambiente [{ "name": "X", "value": "Y" }]; vazio = nenhuma'
        required: false
        type: string
        default: ''
      container_secrets:
        description: 'JSON array de secrets (Secrets Manager) [{ "name": "X", "valueFrom": "arn:..." }]; vazio = nenhum'
        required: false
        type: string
        default: ''
      runtime_cpu_architecture:
        description: 'CPU da plataforma (X86_64, ARM64); vazio = default Fargate'
        required: false
        type: string
        default: ''
      runtime_os_family:
        description: 'OS da plataforma (LINUX, WINDOWS_SERVER_2019_CORE); vazio = default'
        required: false
        type: string
        default: ''
      awslogs_mode:
        description: 'Modo awslogs (non-blocking ou blocking); vazio = n√£o define'
        required: false
        type: string
        default: ''
      awslogs_create_group:
        description: 'Criar log group se n√£o existir (true/false); vazio = n√£o define'
        required: false
        type: string
        default: ''
      awslogs_max_buffer_size:
        description: 'Tamanho m√°ximo do buffer (ex.: 25m); vazio = n√£o define'
        required: false
        type: string
        default: ''
      port_mapping_app_protocol:
        description: 'appProtocol do portMapping (ex.: http); vazio = n√£o define'
        required: false
        type: string
        default: ''
      # --- Service: rebalanceamento, circuit breaker, capacity provider, ECS Exec ---
      enable_zone_rebalancing:
        description: 'Ativar rebalanceamento de zonas de disponibilidade (true/false)'
        required: false
        type: boolean
        default: false
      health_check_grace_period_seconds:
        description: 'Per√≠odo de car√™ncia do health check em segundos (0 ou positivo)'
        required: false
        type: string
        default: ''
      deployment_circuit_breaker_enable:
        description: 'Habilitar disjuntor de implanta√ß√£o (falha autom√°tica do deploy)'
        required: false
        type: boolean
        default: false
      deployment_circuit_breaker_rollback:
        description: 'Fazer rollback autom√°tico quando o disjuntor disparar (requer enable)'
        required: false
        type: boolean
        default: false
      capacity_provider_strategy:
        description: 'Estrat√©gia de capacity providers (ex.: FARGATE=1,FARGATE_SPOT=4 ou JSON); vazio = launch-type FARGATE'
        required: false
        type: string
        default: ''
      platform_version:
        description: 'Vers√£o da plataforma Fargate (ex.: 1.4.0); vazio = default AWS'
        required: false
        type: string
        default: ''
      enable_execute_command:
        description: 'Ativar ECS Exec (comandos interativos no container)'
        required: false
        type: boolean
        default: false
      deployment_minimum_healthy_percent:
        description: 'M√≠nimo % de tarefas saud√°veis durante deploy (ex.: 100); vazio = default AWS'
        required: false
        type: string
        default: ''
      deployment_maximum_percent:
        description: 'M√°ximo % de tarefas durante deploy (ex.: 200); vazio = default AWS'
        required: false
        type: string
        default: ''
      # --- Fim ECS/LB ---
      enable_health_check:
        description: 'Executar health check HTTP p√≥s-deploy (opcional)'
        required: false
        type: boolean
        default: false
      health_check_url:
        description: 'URL do health check (ex.: https://api-dev.example.com/health)'
        required: false
        type: string
        default: ''
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      ECS_CLUSTER:
        required: false
      ECS_SERVICE:
        required: false
      ECS_TASK_EXECUTION_ROLE_ARN:
        required: false
      REPO_ACCESS_TOKEN:
        required: false
    outputs:
      image_digest:
        description: 'Digest da imagem no ECR'
        value: ${{ jobs.pipeline.outputs.image_digest }}
      image_tag:
        description: 'Tag da imagem (SHA)'
        value: ${{ jobs.pipeline.outputs.image_tag }}
      deployed_service_arn:
        description: 'ARN do service ECS atualizado ou criado'
        value: ${{ jobs.pipeline.outputs.deployed_service_arn }}
      task_definition_arn:
        description: 'ARN da task definition registrada neste deploy (para rollback)'
        value: ${{ jobs.pipeline.outputs.task_definition_arn }}

jobs:
  pipeline:
    name: Build, Test, Docker, ECR, ECS
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    continue-on-error: false
    outputs:
      image_digest: ${{ steps.ecr-push.outputs.image_digest }}
      image_tag: ${{ steps.ecr-push.outputs.image_tag }}
      deployed_service_arn: ${{ steps.ecs-deploy.outputs.service_arn }}
      task_definition_arn: ${{ steps.ecs-deploy.outputs.task_definition_arn }}

    steps:
      - name: Validar ambiente e contexto
        id: validate
        run: |
          ENV="${{ inputs.environment }}"
          case "$ENV" in
            dev|qa|sbx|prd) echo "‚úÖ Ambiente v√°lido: $ENV" ;;
            *) echo "‚ùå Ambiente inv√°lido: $ENV"; exit 1 ;;
          esac
          CTX="${{ inputs.context }}"
          case "$CTX" in
            inbound|outbound|platform) echo "‚úÖ Contexto v√°lido: $CTX" ;;
            *) echo "‚ùå Contexto inv√°lido: $CTX"; exit 1 ;;
          esac
          # Nome do reposit√≥rio ECR = context (inbound, outbound ou platform)
          echo "ecr_repository=${CTX}" >> $GITHUB_OUTPUT
          echo "ecr_registry=${{ inputs.ecr_registry }}" >> $GITHUB_OUTPUT
          SERVICE_NAME="${{ inputs.ecs_service }}"
          [ -z "$SERVICE_NAME" ] && SERVICE_NAME="${{ inputs.deployment_name }}"
          echo "ecs_service=${SERVICE_NAME}" >> $GITHUB_OUTPUT

      - name: Checkout aplica√ß√£o
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ inputs.dotnet_version }}

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles(format('{0}/**/*.csproj', inputs.working_directory)) }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore
        working-directory: ${{ inputs.working_directory }}
        run: dotnet restore

      - name: Test
        working-directory: ${{ inputs.working_directory }}
        run: dotnet test --no-restore --verbosity normal

      - name: Checkout templates (Dockerfile padr√£o)
        if: inputs.use_default_dockerfile == true && inputs.templates_repo != ''
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.templates_repo }}
          ref: ${{ inputs.templates_ref }}
          path: .ci-templates
          token: ${{ secrets.REPO_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Definir caminho do Dockerfile
        id: dockerfile-path
        run: |
          if [ "${{ inputs.use_default_dockerfile }}" = "true" ] && [ -n "${{ inputs.templates_repo }}" ]; then
            echo "dockerfile=.ci-templates/build/Dockerfile.${{ inputs.service_type }}" >> $GITHUB_OUTPUT
            echo "‚úÖ Usando Dockerfile padr√£o do repo de templates (build/Dockerfile.${{ inputs.service_type }})"
          else
            CUSTOM="${{ inputs.dockerfile_path }}"
            [ -z "$CUSTOM" ] && CUSTOM="Dockerfile.${{ inputs.service_type }}"
            [ -z "$CUSTOM" ] && CUSTOM="Dockerfile"
            echo "dockerfile=${CUSTOM}" >> $GITHUB_OUTPUT
            echo "‚úÖ Usando Dockerfile do repo da aplica√ß√£o: ${CUSTOM}"
          fi

      - name: Build Docker image
        id: docker-build
        run: |
          BUILD_ARGS=""
          if [ -n "${{ inputs.project_name }}" ]; then
            BUILD_ARGS="--build-arg PROJECT_NAME=${{ inputs.project_name }}"
          fi
          docker build -t ci-build -f ${{ steps.dockerfile-path.outputs.dockerfile }} $BUILD_ARGS .
          echo "‚úÖ Image built locally (tag: ci-build)"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ inputs.aws_region }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Tag and Push to ECR
        id: ecr-push
        env:
          ECR_REPO: ${{ steps.validate.outputs.ecr_repository }}
          REGISTRY: ${{ steps.validate.outputs.ecr_registry }}
          CONTEXT: ${{ inputs.context }}
        run: |
          FULL_IMAGE="${REGISTRY}/${ECR_REPO}:${{ github.sha }}"
          docker tag ci-build "$FULL_IMAGE"
          docker push "$FULL_IMAGE"
          docker tag ci-build "${REGISTRY}/${ECR_REPO}:${{ github.ref_name }}"
          docker push "${REGISTRY}/${ECR_REPO}:${{ github.ref_name }}"
          docker tag ci-build "${REGISTRY}/${ECR_REPO}:${CONTEXT}"
          docker push "${REGISTRY}/${ECR_REPO}:${CONTEXT}"
          TIMESTAMP_TAG="$(date -u +%Y%m%d-%H%M%S)"
          docker tag ci-build "${REGISTRY}/${ECR_REPO}:${TIMESTAMP_TAG}"
          docker push "${REGISTRY}/${ECR_REPO}:${TIMESTAMP_TAG}"
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ci-build | cut -d'@' -f2)
          echo "image_digest=${DIGEST}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "‚úÖ Pushed $FULL_IMAGE (context: $CONTEXT)"

      - name: Registrar nova Task Definition e Deploy (criar ou atualizar service)
        id: ecs-deploy
        env:
          CLUSTER: ${{ inputs.ecs_cluster || secrets.ECS_CLUSTER }}
          SERVICE: ${{ steps.validate.outputs.ecs_service }}
          REGISTRY: ${{ steps.validate.outputs.ecr_registry }}
          ECR_REPO: ${{ steps.validate.outputs.ecr_repository }}
          IMAGE_TAG: ${{ steps.ecr-push.outputs.image_tag }}
          TASK_EXEC_ROLE: ${{ inputs.ecs_task_execution_role_arn || secrets.ECS_TASK_EXECUTION_ROLE_ARN }}
          TASK_ROLE: ${{ inputs.ecs_task_role_arn }}
          CONTAINER_NAME: ${{ inputs.container_name || 'app' }}
          CONTAINER_PORT: ${{ inputs.container_port || '80' }}
          SUBNET_IDS: ${{ inputs.subnet_ids }}
          SECURITY_GROUPS: ${{ inputs.security_group_ids }}
          DESIRED_COUNT: ${{ inputs.desired_count || '1' }}
          ASSIGN_PUBLIC_IP: ${{ inputs.assign_public_ip || 'DISABLED' }}
          TARGET_GROUP_ARN: ${{ inputs.load_balancer_target_group_arn }}
          SERVICE_TYPE: ${{ inputs.service_type }}
          AWS_REGION: ${{ inputs.aws_region }}
          CONTAINER_ENVIRONMENT: ${{ inputs.container_environment }}
          CONTAINER_SECRETS: ${{ inputs.container_secrets }}
          RUNTIME_CPU: ${{ inputs.runtime_cpu_architecture }}
          RUNTIME_OS: ${{ inputs.runtime_os_family }}
          AWSLOGS_MODE: ${{ inputs.awslogs_mode }}
          AWSLOGS_CREATE_GROUP: ${{ inputs.awslogs_create_group }}
          AWSLOGS_MAX_BUFFER: ${{ inputs.awslogs_max_buffer_size }}
          PORT_APP_PROTOCOL: ${{ inputs.port_mapping_app_protocol }}
          ENABLE_ZONE_REBALANCING: ${{ inputs.enable_zone_rebalancing }}
          HEALTH_GRACE_PERIOD: ${{ inputs.health_check_grace_period_seconds }}
          CIRCUIT_BREAKER_ENABLE: ${{ inputs.deployment_circuit_breaker_enable }}
          CIRCUIT_BREAKER_ROLLBACK: ${{ inputs.deployment_circuit_breaker_rollback }}
          CAPACITY_PROVIDER_STRATEGY: ${{ inputs.capacity_provider_strategy }}
          PLATFORM_VERSION: ${{ inputs.platform_version }}
          ENABLE_EXEC_COMMAND: ${{ inputs.enable_execute_command }}
          DEPLOY_MIN_HEALTHY: ${{ inputs.deployment_minimum_healthy_percent }}
          DEPLOY_MAX_PERCENT: ${{ inputs.deployment_maximum_percent }}
        run: |
          set -e
          FULL_IMAGE="${REGISTRY}/${ECR_REPO}:${IMAGE_TAG}"
          echo "üñºÔ∏è Imagem: $FULL_IMAGE"
          if [ -z "$CLUSTER" ] || [ -z "$SERVICE" ]; then
            echo "‚ùå ECS cluster e service s√£o obrigat√≥rios (inputs ecs_cluster/ecs_service ou secrets ECS_CLUSTER/ECS_SERVICE)"
            exit 1
          fi

          # Verificar se o service j√° existe (define fluxo: reutilizar task def vs criar do zero)
          EXISTING=$(aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --query 'services[?status==`ACTIVE`]' --output json)
          SERVICE_EXISTS=$(echo "$EXISTING" | jq 'length > 0')

          if [ "$SERVICE_EXISTS" = "true" ]; then
            # --- Service existe: reutilizar task definition atual, trocar s√≥ imagem e environment (se informado) ---
            echo "üîÑ Service j√° existe: reutilizando task definition e trocando imagem (e environment se informado)..."
            if [ -z "$TASK_EXEC_ROLE" ]; then
              echo "‚ö†Ô∏è Role de execu√ß√£o n√£o informada; task definition atual ser√° preservada (incl. executionRoleArn)"
            fi
            CURRENT_TASK_ARN=$(echo "$EXISTING" | jq -r '.[0].taskDefinition')
            TASK_DEF_JSON=$(aws ecs describe-task-definition --task-definition "$CURRENT_TASK_ARN" --query 'taskDefinition' --output json)
            # Remover campos read-only para re-registro
            TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
            # Trocar imagem do primeiro container
            TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --arg img "$FULL_IMAGE" '.containerDefinitions[0].image = $img')
            # Se container_environment foi informado, substituir environment do primeiro container
            if [ -n "$CONTAINER_ENVIRONMENT" ] && [ "$CONTAINER_ENVIRONMENT" != "[]" ]; then
              if echo "$CONTAINER_ENVIRONMENT" | jq -e . >/dev/null 2>&1; then
                TASK_DEF_JSON=$(echo "$TASK_DEF_JSON" | jq --argjson env "$CONTAINER_ENVIRONMENT" '.containerDefinitions[0].environment = $env')
                echo "üìù Atualizando environment do container com os valores informados"
              fi
            fi
            echo "üìù Registrando nova revis√£o da task definition (imagem + environment se informado)..."
            NEW_TASK_ARN=$(echo "$TASK_DEF_JSON" | aws ecs register-task-definition --cli-input-json file:///dev/stdin --query 'taskDefinition.taskDefinitionArn' --output text)
            echo "task_definition_arn=${NEW_TASK_ARN}" >> $GITHUB_OUTPUT
            echo "‚úÖ Task definition: $NEW_TASK_ARN (reutilizada; imagem e env atualizados)"
          else
            # --- Service n√£o existe: criar task definition do zero (obrigat√≥rio role) ---
            if [ -z "$TASK_EXEC_ROLE" ]; then
              echo "‚ùå Role de execu√ß√£o obrigat√≥ria (input ecs_task_execution_role_arn ou secret ECS_TASK_EXECUTION_ROLE_ARN)"
              exit 1
            fi
            TASK_FAMILY="$SERVICE"
            LOG_GROUP="/ecs/${TASK_FAMILY}"
            PORT_NUM=$(echo "$CONTAINER_PORT" | grep -E '^[0-9]+$' || echo "80")

            PORT_MAPPING=$(jq -n \
              --arg name "${CONTAINER_NAME}-${PORT_NUM}-tcp" \
              --argjson port "$PORT_NUM" \
              --arg appProtocol "$PORT_APP_PROTOCOL" \
              '{
                name: $name,
                containerPort: $port,
                hostPort: $port,
                protocol: "tcp"
              } | if $appProtocol != "" then . + {"appProtocol": $appProtocol} else . end')

            LOG_OPTS=$(jq -n \
              --arg lg "$LOG_GROUP" \
              --arg region "$AWS_REGION" \
              --arg mode "$AWSLOGS_MODE" \
              --arg createGroup "$AWSLOGS_CREATE_GROUP" \
              --arg maxBuf "$AWSLOGS_MAX_BUFFER" \
              '{
                "awslogs-group": $lg,
                "awslogs-region": $region,
                "awslogs-stream-prefix": "ecs"
              } | if $mode != "" then . + {"mode": $mode} else . end | if $createGroup != "" then . + {"awslogs-create-group": $createGroup} else . end | if $maxBuf != "" then . + {"max-buffer-size": $maxBuf} else . end')

            CONTAINER_DEF=$(jq -n \
              --arg name "$CONTAINER_NAME" \
              --arg image "$FULL_IMAGE" \
              --argjson portMapping "$PORT_MAPPING" \
              --argjson logOpts "$LOG_OPTS" \
              '{
                name: $name,
                image: $image,
                portMappings: [$portMapping],
                logConfiguration: { logDriver: "awslogs", options: $logOpts },
                essential: true
              }')

            if [ -n "$CONTAINER_ENVIRONMENT" ] && [ "$CONTAINER_ENVIRONMENT" != "[]" ]; then
              if echo "$CONTAINER_ENVIRONMENT" | jq -e . >/dev/null 2>&1; then
                CONTAINER_DEF=$(echo "$CONTAINER_DEF" | jq --argjson env "$CONTAINER_ENVIRONMENT" '. + {environment: $env}')
              fi
            fi
            if [ -n "$CONTAINER_SECRETS" ] && [ "$CONTAINER_SECRETS" != "[]" ]; then
              if echo "$CONTAINER_SECRETS" | jq -e . >/dev/null 2>&1; then
                CONTAINER_DEF=$(echo "$CONTAINER_DEF" | jq --argjson secrets "$CONTAINER_SECRETS" '. + {secrets: $secrets}')
              fi
            fi

            TASK_DEF_JSON=$(jq -n \
              --arg family "$TASK_FAMILY" \
              --arg execRole "$TASK_EXEC_ROLE" \
              --arg taskRole "$TASK_ROLE" \
              --arg cpu "${{ inputs.task_cpu || '256' }}" \
              --arg memory "${{ inputs.task_memory || '512' }}" \
              --argjson container "$CONTAINER_DEF" \
              --arg runtimeCpu "$RUNTIME_CPU" \
              --arg runtimeOs "$RUNTIME_OS" \
              '{
                family: $family,
                networkMode: "awsvpc",
                requiresCompatibilities: ["FARGATE"],
                cpu: $cpu,
                memory: $memory,
                executionRoleArn: $execRole,
                containerDefinitions: [$container]
              } | if $taskRole != "" then . + {taskRoleArn: $taskRole} else . end | if ($runtimeCpu != "" or $runtimeOs != "") then . + {runtimePlatform: ({} | if $runtimeCpu != "" then . + {cpuArchitecture: $runtimeCpu} else . end | if $runtimeOs != "" then . + {operatingSystemFamily: $runtimeOs} else . end)} else . end')

            echo "üìù Registrando nova revis√£o da task definition (cria√ß√£o do zero)..."
            NEW_TASK_ARN=$(echo "$TASK_DEF_JSON" | aws ecs register-task-definition --cli-input-json file:///dev/stdin --query 'taskDefinition.taskDefinitionArn' --output text)
            echo "task_definition_arn=${NEW_TASK_ARN}" >> $GITHUB_OUTPUT
            echo "‚úÖ Task definition: $NEW_TASK_ARN"
          fi

          # Par√¢metros comuns para create-service e update-service (novos cen√°rio real ECS)
          EXTRA_UPDATE_ARGS=""
          [ "$ENABLE_ZONE_REBALANCING" = "true" ] && EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --enable-zone-rebalancing"
          [ -n "$HEALTH_GRACE_PERIOD" ] && EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --health-check-grace-period-seconds $HEALTH_GRACE_PERIOD"
          if [ "$CIRCUIT_BREAKER_ENABLE" = "true" ]; then
            EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --deployment-circuit-breaker enable=$CIRCUIT_BREAKER_ENABLE,rollback=$CIRCUIT_BREAKER_ROLLBACK"
          fi
          [ -n "$PLATFORM_VERSION" ] && EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --platform-version $PLATFORM_VERSION"
          [ "$ENABLE_EXEC_COMMAND" = "true" ] && EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --enable-execute-command"
          if [ -n "$DEPLOY_MIN_HEALTHY" ] || [ -n "$DEPLOY_MAX_PERCENT" ]; then
            DEPLOY_CFG=""
            [ -n "$DEPLOY_MIN_HEALTHY" ] && DEPLOY_CFG="minimumHealthyPercent=$DEPLOY_MIN_HEALTHY"
            [ -n "$DEPLOY_MAX_PERCENT" ] && { [ -n "$DEPLOY_CFG" ] && DEPLOY_CFG="$DEPLOY_CFG,maximumPercent=$DEPLOY_MAX_PERCENT" || DEPLOY_CFG="maximumPercent=$DEPLOY_MAX_PERCENT"; }
            [ -n "$DEPLOY_CFG" ] && EXTRA_UPDATE_ARGS="$EXTRA_UPDATE_ARGS --deployment-configuration '$DEPLOY_CFG'"
          fi

          LAUNCH_OR_CAPACITY=""
          if [ -n "$CAPACITY_PROVIDER_STRATEGY" ]; then
            CAP_PARTS=""
            for part in $(echo "$CAPACITY_PROVIDER_STRATEGY" | tr ',' ' '); do
              prov=$(echo "$part" | cut -d':' -f1)
              base=$(echo "$part" | cut -d':' -f2)
              weight=$(echo "$part" | cut -d':' -f3)
              [ -z "$base" ] && base=0
              [ -z "$weight" ] && weight=1
              entry="capacityProvider=$prov,weight=$weight,base=$base"
              CAP_PARTS="$CAP_PARTS \"$entry\""
            done
            LAUNCH_OR_CAPACITY="--capacity-provider-strategy $CAP_PARTS"
          else
            LAUNCH_OR_CAPACITY="--launch-type FARGATE"
          fi

          if [ "$SERVICE_EXISTS" = "true" ]; then
            eval aws ecs update-service \
              --cluster "$CLUSTER" \
              --service "$SERVICE" \
              --task-definition "$NEW_TASK_ARN" \
              --force-new-deployment \
              $EXTRA_UPDATE_ARGS \
              --query 'service.serviceArn' \
              --output text
          else
            echo "üÜï Service n√£o existe: criando service e registrando no cluster..."
            if [ -z "$SUBNET_IDS" ] || [ -z "$SECURITY_GROUPS" ]; then
              echo "‚ùå Para criar o service s√£o obrigat√≥rios: subnet_ids e security_group_ids"
              exit 1
            fi
            SUBNETS=$(echo "$SUBNET_IDS" | tr ',' '\n' | jq -R . | jq -s .)
            SGS=$(echo "$SECURITY_GROUPS" | tr ',' '\n' | jq -R . | jq -s .)
            NETWORK_CONFIG=$(jq -n \
              --argjson subnets "$SUBNETS" \
              --argjson sgs "$SGS" \
              --arg assign "$ASSIGN_PUBLIC_IP" \
              '{ awsvpcConfiguration: { subnets: $subnets, securityGroups: $sgs, assignPublicIp: $assign } }')

            if [ "$SERVICE_TYPE" = "api" ] && [ -n "$TARGET_GROUP_ARN" ]; then
              echo "üìå API com Load Balancer: target group $TARGET_GROUP_ARN"
              LB_JSON=$(jq -n \
                --arg tg "$TARGET_GROUP_ARN" \
                --arg cn "$CONTAINER_NAME" \
                --argjson cp "$PORT_NUM" \
                '[{ targetGroupArn: $tg, containerName: $cn, containerPort: $cp }]')
              eval aws ecs create-service \
                --cluster "$CLUSTER" \
                --service-name "$SERVICE" \
                --task-definition "$NEW_TASK_ARN" \
                --desired-count "$(echo "$DESIRED_COUNT" | sed 's/^0*//' || echo 1)" \
                --network-configuration "$NETWORK_CONFIG" \
                --load-balancers "$LB_JSON" \
                $EXTRA_UPDATE_ARGS \
                $LAUNCH_OR_CAPACITY \
                --query 'service.serviceArn' \
                --output text
            else
              echo "üìå Worker (sem Load Balancer)"
              eval aws ecs create-service \
                --cluster "$CLUSTER" \
                --service-name "$SERVICE" \
                --task-definition "$NEW_TASK_ARN" \
                --desired-count "$(echo "$DESIRED_COUNT" | sed 's/^0*//' || echo 1)" \
                --network-configuration "$NETWORK_CONFIG" \
                $EXTRA_UPDATE_ARGS \
                $LAUNCH_OR_CAPACITY \
                --query 'service.serviceArn' \
                --output text
            fi
          fi

          echo "service_arn=$(aws ecs describe-services --cluster $CLUSTER --services $SERVICE --query 'services[0].serviceArn' --output text)" >> $GITHUB_OUTPUT
          echo "‚è≥ Aguardando deployment estabilizar..."
          aws ecs wait services-stable --cluster "$CLUSTER" --services "$SERVICE"
          echo "‚úÖ Deployment conclu√≠do"

      - name: Gerar deploy metadata (hist√≥rico e rollback)
        id: deploy-meta
        if: success()
        run: |
          mkdir -p .deploys
          cat << EOF > .deploys/deploy.json
          {
            "environment": "${{ inputs.environment }}",
            "deployment_name": "${{ inputs.deployment_name }}",
            "image_digest": "${{ steps.ecr-push.outputs.image_digest }}",
            "image_tag": "${{ steps.ecr-push.outputs.image_tag }}",
            "task_definition_arn": "${{ steps.ecs-deploy.outputs.task_definition_arn }}",
            "service_arn": "${{ steps.ecs-deploy.outputs.service_arn }}",
            "commit_sha": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "run_id": "${{ github.run_id }}",
            "run_url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF
          echo "path=.deploys" >> $GITHUB_OUTPUT

      - name: Upload deploy metadata
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: deploy-${{ inputs.environment }}-${{ inputs.deployment_name }}-${{ github.run_id }}
          path: .deploys

      - name: Health check (opcional)
        if: inputs.enable_health_check == true && inputs.health_check_url != ''
        run: |
          URL="${{ inputs.health_check_url }}"
          MAX_ATTEMPTS=12
          INTERVAL=10
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if curl -sf "$URL" > /dev/null; then
              echo "‚úÖ Health check OK em $URL"
              exit 0
            fi
            echo "Tentativa $i/$MAX_ATTEMPTS falhou; aguardando ${INTERVAL}s..."
            sleep $INTERVAL
          done
          echo "‚ùå Health check falhou ap√≥s $MAX_ATTEMPTS tentativas"
          exit 1
